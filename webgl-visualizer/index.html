<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <style>
    :root {
      --primary-bg: #0a0a0a;
      --accent: #ff0077;
      --control-bg: rgba(15, 15, 15, 0.95);
      --text-primary: rgba(255, 255, 255, 0.95);
      --text-secondary: rgba(255, 255, 255, 0.7);
    }
    body {
      margin: 0;
      background: linear-gradient(45deg, #0a0a0a 0%, #1a1a1a 100%);
      color: var(--text-primary);
      font-family: 'Inter', sans-serif;
    }
    canvas {
      display: block;
      filter: contrast(1.3) brightness(1.1);
    }
    #controls {
      position: fixed;
      top: 20px;
      right: 20px;
      background: var(--control-bg);
      padding: 1.25rem;
      border-radius: 12px;
      z-index: 100;
      backdrop-filter: blur(16px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.25);
    }
    .control-group {
      margin: 1rem 0;
    }
    #controls label {
      display: block;
      margin: 0.5rem 0;
      font-size: 0.875rem;
      color: var(--text-secondary);
      font-weight: 500;
    }
    #controls input,
    #controls select,
    #controls button {
      width: 100%;
      padding: 1rem 0rem;
      border-radius: 8px;
      border: 1px solid var(--primary-bg);
      background: rgba(0, 0, 0, 0.4);
      color: var(--text-primary);
      font-family: inherit;
      transition: all 0.2s ease;
    }
    #controls input:focus,
    #controls select:focus {
      outline: none;
      border-color: var(--accent);
      box-shadow: 0 0 0 3px rgba(255, 0, 119, 0.1);
    }
    #controls button {
      background: var(--accent);
      border: none;
      font-weight: 600;
      cursor: pointer;
      margin: 0.5rem 0;
      transition: transform 0.1s ease, background 0.2s ease;
    }
    #controls button:hover {
      background: #ff0066;
      transform: translateY(-1px);
    }
    #controls button:active {
      transform: translateY(0);
    }
    #controls button[disabled] {
      background: rgba(255, 255, 255, 0.1);
      cursor: not-allowed;
      opacity: 0.7;
    }
    #modeDisplay {
      font-weight: 600;
      margin: 0 0 1rem 0;
      padding: 0.5rem 1rem;
      background: rgba(255, 255, 255, 0.05);
      border-radius: 6px;
      color: var(--accent);
      text-align: center;
    }
    .key-hint {
      font-size: 0.8rem;
      color: var(--text-secondary);
      text-align: center;
      margin: 1rem 0;
      padding: 0.75rem;
      background: rgba(255, 255, 255, 0.03);
      border-radius: 6px;
    }
    #previewContainer {
      position: fixed;
      bottom: 20px;
      right: 20px;
      background: var(--control-bg);
      padding: 1.25rem;
      border-radius: 12px;
      z-index: 101;
      display: none;
      max-width: 400px;
      backdrop-filter: blur(8px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.25);
    }
    #previewContainer video {
      width: 100%;
      border-radius: 8px;
      margin-bottom: 1rem;
      background: #000;
    }
    .button-group {
      display: flex;
      gap: 0.5rem;
      margin-top: 1rem;
    }
    input[type="color"] {
      padding: 0 !important;
      height: 40px;
      cursor: pointer;
    }
    input[type="color"]::-webkit-color-swatch {
      border: none;
      border-radius: 6px;
    }
    .dimension-group {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 0.75rem;
    }
    .dimension-input {
      position: relative;
    }
    .dimension-input input {
      text-align: center;
    }
    .dimension-input input:focus {
      border-color: var(--accent);
      box-shadow: 0 0 0 3px rgba(255, 0, 119, 0.1);
      outline: none;
    }
    .dimension-input input[type="number"]::-webkit-inner-spin-button,
    .dimension-input input[type="number"]::-webkit-outer-spin-button {
      -webkit-appearance: none;
      appearance: none;
      margin: 0;
    }
    .dimension-input input[type="number"] {
      -moz-appearance: textfield;
      appearance: textfield;
    }
    .dimension-controls {
      position: absolute;
      right: 4px;
      top: 75%;
      transform: translateY(-50%);
      display: flex;
      flex-direction: column;
    }
    .dimension-button {
      max-height: 10px;
      background: rgba(255, 255, 255, 0.05);
      border: none;
      color: var(--text-secondary);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 3px;
      transition: all 0.2s ease;
    }
    .dimension-button:hover {
      background: rgba(255, 255, 255, 0.1);
      color: var(--text-primary);
    }
    .dimension-button:active {
      background: var(--accent);
    }
  </style>
</head>
<body>
  <canvas id="visualizerCanvas"></canvas>
  <div id="controls">
    <div id="modeDisplay">Mode: Loading...</div>
    <div class="control-group">
      <label for="audioUpload">Load Audio File</label>
      <input type="file" id="audioUpload" accept="audio/*" />
    </div>
    <div class="control-group">
      <label for="qualitySelect">Recording Quality</label>
      <select id="qualitySelect">
        <option value="low">Low (2.5 Mbps)</option>
        <option value="medium" selected>Medium (5 Mbps)</option>
        <option value="high">High (10 Mbps)</option>
      </select>
    </div>
    <div class="control-group">
      <div class="dimension-group">
        <div class="dimension-input">
          <label for="canvasWidth">Canvas Width</label>
          <input type="number" id="canvasWidth" value="800" min="100" max="4000" />
          <div class="dimension-controls">
            <button class="dimension-button" data-target="canvasWidth" data-direction="up">▲</button>
            <button class="dimension-button" data-target="canvasWidth" data-direction="down">▼</button>
          </div>
        </div>
        <div class="dimension-input">
          <label for="canvasHeight">Canvas Height</label>
          <input type="number" id="canvasHeight" value="600" min="100" max="4000" />
          <div class="dimension-controls">
            <button class="dimension-button" data-target="canvasHeight" data-direction="up">▲</button>
            <button class="dimension-button" data-target="canvasHeight" data-direction="down">▼</button>
          </div>
        </div>
      </div>
    </div>
    <div class="control-group">
      <label for="userColor">Visualizer Color</label>
      <input type="color" id="userColor" value="#ff0077" />
    </div>
    <div class="key-hint">Use ← → arrow keys to switch animations</div>
    <button id="startRecording">Start Recording</button>
    <button id="stopRecording" disabled>Stop Recording</button>
  </div>
  <div id="previewContainer">
    <video id="previewVideo" controls></video>
    <div class="button-group">
      <button id="downloadRecording" style="flex:1;">Download</button>
      <button id="closePreview" style="flex:1;">✕ Close</button>
    </div>
  </div>
  <script>
    const canvas = document.getElementById("visualizerCanvas");
    const gl = canvas.getContext("webgl", {
      antialias: true,
      preserveDrawingBuffer: true,
    });
    if (!gl) {
      alert("WebGL not supported");
      throw new Error("WebGL not supported");
    }
    const qualitySettings = {
      low: { videoBitsPerSecond: 2500000 },
      medium: { videoBitsPerSecond: 5000000 },
      high: { videoBitsPerSecond: 10000000 }
    };
    function resizeCanvas() {
      const widthInput = document.getElementById("canvasWidth").value;
      const heightInput = document.getElementById("canvasHeight").value;
      const userWidth = parseInt(widthInput, 10) || window.innerWidth;
      const userHeight = parseInt(heightInput, 10) || window.innerHeight;
      const dpr = window.devicePixelRatio || 1;
      canvas.width = userWidth * dpr;
      canvas.height = userHeight * dpr;
      canvas.style.width = userWidth + "px";
      canvas.style.height = userHeight + "px";
      gl.viewport(0, 0, canvas.width, canvas.height);
    }
    document.getElementById("canvasWidth").addEventListener("input", resizeCanvas);
    document.getElementById("canvasHeight").addEventListener("input", resizeCanvas);
    window.addEventListener("resize", resizeCanvas);
    resizeCanvas();
    class ShaderProgram {
      constructor(vertexSrc, fragmentSrc) {
        this.program = this.createProgram(vertexSrc, fragmentSrc);
      }
      createShader(source, type) {
        const shader = gl.createShader(type);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
          const error = gl.getShaderInfoLog(shader);
          gl.deleteShader(shader);
          throw new Error("Shader compile error: " + error);
        }
        return shader;
      }
      createProgram(vertexSrc, fragmentSrc) {
        const vertexShader = this.createShader(vertexSrc, gl.VERTEX_SHADER);
        const fragmentShader = this.createShader(fragmentSrc, gl.FRAGMENT_SHADER);
        const program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);
        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
          const error = gl.getProgramInfoLog(program);
          gl.deleteProgram(program);
          throw new Error("Program link error: " + error);
        }
        return program;
      }
      use() {
        gl.useProgram(this.program);
      }
      getAttribLocation(name) {
        return gl.getAttribLocation(this.program, name);
      }
      getUniformLocation(name) {
        return gl.getUniformLocation(this.program, name);
      }
    }
    class AnimationModule {
      constructor(name, fragmentSrc) {
        this.name = name;
        this.shader = new ShaderProgram(vsSource, fragmentSrc);
        this.uniforms = {
          uTime: gl.getUniformLocation(this.shader.program, "uTime"),
          uResolution: gl.getUniformLocation(this.shader.program, "uResolution"),
          uAudioLevel: gl.getUniformLocation(this.shader.program, "uAudioLevel"),
          uUserColor: gl.getUniformLocation(this.shader.program, "uUserColor"),
        };
      }
      use() {
        this.shader.use();
      }
    }
    const vsSource = `
      attribute vec2 aPosition;
      void main(){
        gl_Position = vec4(aPosition, 0.0, 1.0);
      }
    `;
    const fsSourceWaves = `
      precision mediump float;
      uniform float uTime;
      uniform vec2 uResolution;
      uniform float uAudioLevel;
      uniform vec3 uUserColor;
      void main(void) {
        vec2 uv = (gl_FragCoord.xy - 0.5 * uResolution) / uResolution.y;
        float angle = atan(uv.y, uv.x);
        float radius = length(uv);
        float wave = sin(10.0 * radius - uTime * 2.0 + uAudioLevel * 5.0) + sin(5.0 * angle + uTime);
        vec3 base = vec3(0.5);
        vec3 col = mix(base, uUserColor, 0.5 + 0.5 * sin(uTime + wave));
        gl_FragColor = vec4(col, 1.0);
      }
    `;
    const fsSourceTunnel = `
      precision mediump float;
      uniform float uTime;
      uniform vec2 uResolution;
      uniform float uAudioLevel;
      uniform vec3 uUserColor;
      void main(void) {
        vec2 uv = (gl_FragCoord.xy - 0.5 * uResolution) / uResolution.y;
        float angle = atan(uv.y, uv.x);
        float radius = length(uv);
        float stripes = sin(10.0 * radius - uTime * 5.0 + uAudioLevel * 10.0);
        vec3 base = vec3(0.3);
        vec3 col = mix(base, uUserColor, 0.5 + 0.5 * cos(uTime + stripes + angle));
        gl_FragColor = vec4(col, 1.0);
      }
    `;
    const fsSourceSpectrum = `
      precision mediump float;
      uniform float uTime;
      uniform vec2 uResolution;
      uniform float uAudioLevel;
      uniform vec3 uUserColor;
      void main(void) {
        vec2 uv = gl_FragCoord.xy / uResolution;
        float barWidth = 0.05;
        float index = floor(uv.x / barWidth);
        float modTime = mod(uTime + index, 1.0);
        float bar = step(0.5, fract(uv.y * 10.0 + modTime + uAudioLevel * 5.0));
        vec3 col = mix(vec3(0.0), uUserColor, bar);
        gl_FragColor = vec4(col, 1.0);
      }
    `;
    const fsSourceParticles = `
      precision highp float;
      uniform float uTime;
      uniform vec2 uResolution;
      uniform float uAudioLevel;
      uniform vec3 uUserColor;
      float random(vec2 st) {
          return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);
      }
      void main() {
          vec2 uv = gl_FragCoord.xy/uResolution.xy;
          uv.x *= uResolution.x/uResolution.y;
          vec3 color = vec3(0.0);
          float particleCount = 50.0 + uAudioLevel * 100.0;
          for(float i = 0.0; i < 50.0; i++) {
              if(i >= particleCount) break;
              vec2 pos = vec2(
                  random(vec2(i)) + sin(uTime*0.5 + i) * 0.3,
                  fract(random(vec2(i*2.0)) + uTime*0.2 * (0.5 + uAudioLevel))
              );
              float dist = length(uv - pos);
              color += uUserColor * 0.02/(dist*15.0) * (1.0 + uAudioLevel*5.0);
          }
          gl_FragColor = vec4(color,1.0);
      }
    `;
    const fsSourceGrid = `
      precision highp float;
      uniform float uTime;
      uniform vec2 uResolution;
      uniform float uAudioLevel;
      uniform vec3 uUserColor;
      void main() {
          vec2 uv = (gl_FragCoord.xy * 2.0 - uResolution.xy) / min(uResolution.x, uResolution.y);
          uv *= 2.0 + uAudioLevel * 3.0;
          vec2 grid = fract(uv * 2.0);
          grid = abs(grid - 0.5);
          float line = min(grid.x, grid.y);
          float mask = smoothstep(0.1, 0.05, line);
          vec3 color = mix(vec3(0.1), uUserColor, mask);
          color *= sin(uTime + uv.x * 2.0) * 0.5 + 0.5;
          color += pow(1.0 - line, 20.0) * uUserColor * (0.5 + uAudioLevel);
          gl_FragColor = vec4(color, 1.0);
      }
    `;
    const fsSourcePlasma = `
      precision highp float;
      uniform float uTime;
      uniform vec2 uResolution;
      uniform float uAudioLevel;
      uniform vec3 uUserColor;
      void main() {
          vec2 uv = gl_FragCoord.xy / uResolution.xy * 2.0 - 1.0;
          uv.x *= uResolution.x / uResolution.y;
          float t = uTime * 0.5;
          float c = sin(t + uv.x * 5.0) + 
                  sin(t + uv.y * 3.0) + 
                  sin((t + uv.x + uv.y) * 4.0) * uAudioLevel * 2.0;
          vec3 color = uUserColor * (0.5 + 0.5 * sin(c * 3.0 + uTime)) * 
                      (1.0 - length(uv) * 0.3) * 
                      (1.0 + uAudioLevel * 2.0);
          gl_FragColor = vec4(color, 1.0);
      }
    `;
    const fsSourceNeon = `
      precision highp float;
      uniform float uTime;
      uniform vec2 uResolution;
      uniform float uAudioLevel;
      uniform vec3 uUserColor;
      void main() {
          vec2 uv = gl_FragCoord.xy / uResolution.xy;
          uv.x *= uResolution.x / uResolution.y;
          float speed = uTime * 0.5;
          float gridSize = 0.2 + uAudioLevel * 0.3;
          vec2 grid = fract(uv * 5.0 + vec2(speed));
          float line = min(abs(grid.x - 0.5), abs(grid.y - 0.5));
          float glow = exp(-20.0 * line) * (1.0 + sin(speed * 5.0) * 0.5);
          vec3 color = uUserColor * glow * (1.0 + uAudioLevel * 3.0);
          gl_FragColor = vec4(color, 1.0);
      }
    `;
    const fsSourceRadial = `
      precision highp float;
      uniform float uTime;
      uniform vec2 uResolution;
      uniform float uAudioLevel;
      uniform vec3 uUserColor;
      void main() {
          vec2 uv = (gl_FragCoord.xy - 0.5 * uResolution.xy) / uResolution.y;
          float radius = length(uv) * 3.0;
          float angle = atan(uv.y, uv.x);
          float wave = sin(radius * 10.0 - uTime * 5.0) * 
                      cos(angle * 5.0 + uTime) * 
                      (1.0 + uAudioLevel * 3.0);
          vec3 color = uUserColor * smoothstep(0.4, 0.5, abs(wave));
          color *= 1.0 - radius * 0.3;
          gl_FragColor = vec4(color, 1.0);
      }
    `;
    const fsSourceMoire = `
      precision highp float;
      uniform float uTime;
      uniform vec2 uResolution;
      uniform float uAudioLevel;
      uniform vec3 uUserColor;
      void main() {
          vec2 uv = gl_FragCoord.xy / uResolution.xy * 10.0;
          uv.x *= uResolution.x / uResolution.y;
          float pattern1 = sin(uv.x * 10.0 + uTime) * 
                          cos(uv.y * 8.0 + uTime);
          float pattern2 = sin((uv.x + uv.y) * 15.0 + uTime) * 
                          (1.0 + uAudioLevel * 2.0);
          float combined = sin(pattern1 * 5.0 + pattern2 * 3.0);
          vec3 color = uUserColor * (0.5 + 0.5 * combined);
          gl_FragColor = vec4(color, 1.0);
      }
    `;
    const animationModules = [
      new AnimationModule("Waves", fsSourceWaves),
      new AnimationModule("Tunnel", fsSourceTunnel),
      new AnimationModule("Spectrum", fsSourceSpectrum),
      new AnimationModule("Particles", fsSourceParticles),
      new AnimationModule("Geometric Grid", fsSourceGrid),
      new AnimationModule("Liquid Plasma", fsSourcePlasma),
      new AnimationModule("Neon Grid", fsSourceNeon),
      new AnimationModule("Radial Waves", fsSourceRadial),
      new AnimationModule("Moire Pattern", fsSourceMoire)
    ];
    let currentAnimationIndex = 0;
    function updateModeDisplay() {
      document.getElementById("modeDisplay").textContent = "Mode: " + animationModules[currentAnimationIndex].name;
    }
    updateModeDisplay();
    const vertices = new Float32Array([
      -1, -1,   1, -1,   -1, 1,
      -1, 1,   1, -1,    1, 1
    ]);
    const buffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
    gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
    function bindAttributes(program) {
      const aPosition = gl.getAttribLocation(program, "aPosition");
      gl.enableVertexAttribArray(aPosition);
      gl.vertexAttribPointer(aPosition, 2, gl.FLOAT, false, 0, 0);
    }
    let audioBuffer = null, analyser = null, dataArray = null, sourceNode = null;
    const AudioContext = window.AudioContext || window.webkitAudioContext;
    const audioCtx = new AudioContext();
    const dest = audioCtx.createMediaStreamDestination();
    document.getElementById("audioUpload").addEventListener("change", async (e) => {
      const file = e.target.files[0];
      if (file) {
        const arrayBuffer = await file.arrayBuffer();
        audioBuffer = await audioCtx.decodeAudioData(arrayBuffer);
        console.log("Audio file loaded.");
      }
    });
    let startTime = null;
    function render(timestamp) {
      if (!startTime) startTime = timestamp;
      const elapsed = (timestamp - startTime) / 1000.0;
      const animModule = animationModules[currentAnimationIndex];
      animModule.use();
      bindAttributes(animModule.shader.program);
      gl.clearColor(0.0, 0.0, 0.0, 1.0);
      gl.clear(gl.COLOR_BUFFER_BIT);
      gl.uniform1f(animModule.uniforms.uTime, elapsed);
      gl.uniform2f(animModule.uniforms.uResolution, canvas.width, canvas.height);
      let audioLevel = 0.0;
      if (analyser && dataArray) {
        analyser.getByteFrequencyData(dataArray);
        let sum = 0;
        for (let i = 0; i < dataArray.length; i++) {
          sum += dataArray[i];
        }
        audioLevel = sum / dataArray.length / 255;
      }
      gl.uniform1f(animModule.uniforms.uAudioLevel, audioLevel);
      const userColorHex = document.getElementById("userColor").value;
      const rgb = hexToRgb(userColorHex);
      gl.uniform3f(animModule.uniforms.uUserColor, rgb[0], rgb[1], rgb[2]);
      gl.drawArrays(gl.TRIANGLES, 0, 6);
      requestAnimationFrame(render);
    }
    requestAnimationFrame(render);
    function hexToRgb(hex) {
      let r = parseInt(hex.slice(1, 3), 16) / 255;
      let g = parseInt(hex.slice(3, 5), 16) / 255;
      let b = parseInt(hex.slice(5, 7), 16) / 255;
      return [r, g, b];
    }
    window.addEventListener("keydown", (e) => {
      if (e.key === "ArrowRight") {
        currentAnimationIndex = (currentAnimationIndex + 1) % animationModules.length;
        updateModeDisplay();
      } else if (e.key === "ArrowLeft") {
        currentAnimationIndex = (currentAnimationIndex - 1 + animationModules.length) % animationModules.length;
        updateModeDisplay();
      }
    });
    document.querySelectorAll('.dimension-button').forEach(button => {
      let intervalId = null;
      let timeoutId = null;
      const startAction = () => {
        const target = document.getElementById(button.dataset.target);
        const direction = button.dataset.direction;
        const step = direction === 'up' ? 50 : -50;
        target.value = Math.max(100, parseInt(target.value || 0) + step);
        target.dispatchEvent(new Event('input'));
        timeoutId = setTimeout(() => {
          intervalId = setInterval(() => {
            target.value = Math.max(100, parseInt(target.value || 0) + step);
            target.dispatchEvent(new Event('input'));
          }, 50);
        }, 300);
      };
      const stopAction = () => {
        clearTimeout(timeoutId);
        clearInterval(intervalId);
      };
      button.addEventListener('mousedown', startAction);
      button.addEventListener('mouseup', stopAction);
      button.addEventListener('mouseleave', stopAction);
    });
    let mediaRecorder, chunks = [];
    const qualitySelect = document.getElementById("qualitySelect");
    const startBtn = document.getElementById("startRecording");
    const stopBtn = document.getElementById("stopRecording");
    const previewContainer = document.getElementById("previewContainer");
    const previewVideo = document.getElementById("previewVideo");
    const downloadBtn = document.getElementById("downloadRecording");
    const closePreviewBtn = document.getElementById("closePreview");
    startBtn.addEventListener("click", async () => {
      await audioCtx.resume();
      chunks = [];
      if (audioBuffer) {
        if (sourceNode) {
          try { sourceNode.stop(); } catch (e) {}
        }
        sourceNode = audioCtx.createBufferSource();
        sourceNode.buffer = audioBuffer;
        const gainNode = audioCtx.createGain();
        sourceNode.connect(gainNode);
        analyser = audioCtx.createAnalyser();
        analyser.fftSize = 512;
        dataArray = new Uint8Array(analyser.frequencyBinCount);
        gainNode.connect(analyser);
        gainNode.connect(audioCtx.destination);
        gainNode.connect(dest);
        sourceNode.start(0);
      }
      const canvasStream = canvas.captureStream(60);
      const audioStream = dest.stream;
      const tracks = [...canvasStream.getTracks(), ...audioStream.getTracks()];
      const combinedStream = new MediaStream(tracks);
      const selectedQuality = qualitySettings[qualitySelect.value];
      mediaRecorder = new MediaRecorder(combinedStream, {
        mimeType: "video/webm;codecs=vp9,opus",
        ...selectedQuality
      });
      mediaRecorder.ondataavailable = (e) => {
        if (e.data && e.data.size > 0) chunks.push(e.data);
      };
      mediaRecorder.onstop = () => {
        const blob = new Blob(chunks, { type: "video/webm" });
        const url = URL.createObjectURL(blob);
        previewVideo.src = url;
        previewVideo.load();
        previewContainer.style.display = "block";
        downloadBtn.onclick = () => {
          const a = document.createElement("a");
          a.href = url;
          a.download = "visualization.webm";
          document.body.appendChild(a);
          a.click();
          a.remove();
        };
      };
      mediaRecorder.start(1000);
      startBtn.disabled = true;
      stopBtn.disabled = false;
    });
    stopBtn.addEventListener("click", () => {
      mediaRecorder.stop();
      startBtn.disabled = false;
      stopBtn.disabled = true;
      if (sourceNode) {
        try { sourceNode.stop(); } catch (e) {}
      }
    });
    closePreviewBtn.addEventListener("click", () => {
      previewContainer.style.display = "none";
      previewVideo.src = "";
    });
  </script>
</body>
</html>